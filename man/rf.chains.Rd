% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RF.R
\name{rf.chains}
\alias{rf.chains}
\title{Scaled Subposterior Parallelization for Parameter Estimation}
\usage{
rf.chains(
  lambda,
  chains,
  para,
  startval,
  niter,
  X,
  prior,
  likelihood,
  propvar,
  random = T,
  burn.rate = 0.1
)
}
\arguments{
\item{lambda}{A numeric tuning parameter. The larger its value, the more confidence is placed in the subposterior (see references for details). Must be positive.}

\item{chains}{Number of subsets in the simulation. Used when a divide-and-conquer algorithm is employed.}

\item{para}{Parameters to be estimated.}

\item{startval}{Initial value of the chain.}

\item{niter}{Number of iterations (including burned iterations).}

\item{X}{Matrix of observations from the underlying data set.}

\item{prior}{Prior function for the parameters.}

\item{likelihood}{Likelihood function.}

\item{propvar}{The diagonal of the variance matrix for the proposal distribution. If no value is specified, the identify matrix is used.}

\item{random}{If true, the rows of X are shuffled prior to the split.}

\item{burn.rate}{The percentage of iterations to be burned.}
}
\value{
A list with the following items:
\describe{
\item{\code{Chains}}{A list of dataframes, one for each subset, containing the generated Markov chains.}
\item{\code{Estimate}}{The parameter estimate obtained using the scaled subposterior method.}
}
}
\description{
This function estimates the parameters of a model using the scaled subposterior approach proposed by Wu and Robert (2019). It models the subposterior of subset \eqn{X_k} as
\deqn{\pi_k(\theta | X_k) ‚àù (\pi(\theta)^(1/K) \prod p(x|\theta))^\lambda}
where \eqn{\lambda} is a tuning parameter. The estimates are then averaged using importance sampling and random forests.
}
\examples{
#Parameter Estimation for Data from a Weibull Distribution

#Prior
prior<-function(param){
  ifelse(all(param>0), 1, 0)
}

#Likelihood
weibull.likelihood<-function(X, param){
  shape=param[1]
  scale=param[2]
  sum(dweibull(x=X, shape, scale, log=T))
}

#Simulate data
X<-rweibull(100, 2, 1.2)

#Parameters
para<-c("shape", "scale")
niter<-10000
startval<-c(2.5, 1.1)
chains=3
burn.rate<-0.1
propvar<-0.5
lambda<-2

df<-rf.chains(lambda, chains, para, startval, niter, X, prior,
              likelihood=weibull.likelihood, propvar=propvar)
}
\references{
Changye Wu and Christian P. Robert. Parallelising MCMC via Random Forests. arXiv e-prints, art. arXiv:1911.09698, 2019.
}
